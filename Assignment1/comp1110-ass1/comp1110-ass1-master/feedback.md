# Assignment One Feedback
## Tutor Comment

Well done!! All tasks (including challenging ones) completed. Good habit to write comments for your codes. Better to have neat spacing between different methods (may consider to do the clean up before the submission). 

## Mark

**5.0/5.0**

## Miscellaneous marks

| Level | Requirement | Result |
|:-:|---|:-:|
|P|Forked assignment 1 repository | 0.5/0.5 |
|P|Originality statement edited, committed, pushed | 0.5/0.5 |
|P|Git log file reveals healthy use of git | 0.25/0.25 |
|P|Edited classes compile correctly | 0.25/0.25 |
|CR|Code is of high quality | 0.25/0.25 |
|HD|Solution is outstanding in its design and implementation | 0.5/0.5 |

**Total for miscellaneous marks:** 2.25/2.25

## Test results

| Task | Test | Result | Worth |
|:-:|---|:-:|:-:|
|2|PieceFixed|2/2|.5|
|3|FixOrientations|5/5|.5|
|4|SampleObjective|3/3|.25|
|5|GetCovered|7/7|.5|
|6|FindSolutions|6/6|.5|
|7|InterestingObjective|3/3|.5|

**Total for tests:** running tests for u6361796
2.75/2.75


## Statement of Originality

I declare that the work I have submitted for assignment one is entirely my own work, with the following documented exceptions:

* The idea of <Bit Board, bit shift> came from a discussion with <Aaron (Hang) Zhou>

* The code in class <...> uses an idea suggested by <...>

Signed: Wenbo Du (u6361796)

## Git Log
```
commit 5d483eec44b9dd18226ceedc4ec5701a69139e74
Author: Wenbo  Du <u6361796@anu.edu.au>
Date:   Thu Mar 8 21:52:36 2018 +1100

    Update originality.md

commit 75d09fcd8808958aead355bd0df9d338ddcc6214
Author: u6361796 <u6361796@anu.edu.au>
Date:   Thu Mar 8 21:41:12 2018 +1100

    all done

commit a8816e21db761ef009187c9954b224be83d83ff3
Author: u6361796 <u6361796@anu.edu.au>
Date:   Thu Mar 8 13:33:49 2018 +1100

    finished

commit 22d873e365b9fff211fcb456197c52843f377f50
Author: u6361796 <u6361796@anu.edu.au>
Date:   Thu Mar 8 13:31:37 2018 +1100

    finished and just need comment

commit 371d336d78e1ae2c140480eb3178a889d1d1184f
Merge: 7ef38e0 dbd4d8b
Author: u6361796 <u6361796@anu.edu.au>
Date:   Mon Mar 5 23:24:34 2018 +1100

    Task 6 really done

commit 7ef38e065955ce5209d42d15b7caad219284c48e
Author: u6361796 <u6361796@anu.edu.au>
Date:   Sun Mar 4 12:20:32 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass1
    
    # Conflicts:
    #       src/comp1110/ass1/IQPuzzlerPro.java
    #       src/comp1110/ass1/Piece.java

commit dbd4d8bf1970c46645a7a7f4d7ddb4ffea865579
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sun Mar 4 12:06:44 2018 +1100

    complete set of tests for task 6

commit 58d6565bf7fe09c4a1f97f4d4ff394152a683006
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Thu Mar 1 22:46:12 2018 +1100

    update Javadoc for task 6

commit f392be2f52e0966fdfff6820d4c41d424e0e6845
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Thu Mar 1 22:23:06 2018 +1100

    IQPuzzlerPro.fixOrientations is not useful to implement tasks 6 and 7.
    
    Added a new method fixOrientationsProperly as a useful building block
    for these later tasks.
    
    Thanks to Huang Sukai and Will Massey for suggesting this fix

commit ba94af90b6cc6aa5b94bc6d9b534ff56d3a54bcc
Author: u6361796 <u6361796@anu.edu.au>
Date:   Thu Mar 1 16:58:51 2018 +1100

    task 6 done

commit 9b32263da8edb661b0f8f3604c33c1986f4da164
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Wed Feb 28 20:03:02 2018 +1100

    fix errors in JUnit test error messages for FixOrientationsTest.testJavadocExamples

commit 978d42badc1f833a82245509f72ad7be073baddf
Author: u6361796 <u6361796@anu.edu.au>
Date:   Wed Feb 28 12:39:53 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass1
    
    # Conflicts:
    #       src/comp1110/ass1/IQPuzzlerPro.java
    #       src/comp1110/ass1/Piece.java

commit 63fe02a61c90e383a9cdbdbfb3c1c9408cdec25a
Author: u6361796 <u6361796@anu.edu.au>
Date:   Wed Feb 28 12:33:48 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass1
    
    # Conflicts:
    #       src/comp1110/ass1/IQPuzzlerPro.java
    #       src/comp1110/ass1/Piece.java

commit 1e4d3d082dcf6dc3b59642639695f888a61fb117
Merge: daf4508 51547b6
Author: u6361796 <u6361796@anu.edu.au>
Date:   Wed Feb 28 12:24:56 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass1
    
    # Conflicts:
    #       src/comp1110/ass1/IQPuzzlerPro.java
    #       src/comp1110/ass1/Piece.java

commit daf45083e7b225f25d9bba811caad5f2781389a4
Author: u6361796 <u6361796@anu.edu.au>
Date:   Tue Feb 27 12:58:01 2018 +1100

    a bug find

commit 51547b61e47cb429a99cbbe3287f34f2c9355daa
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sat Feb 24 20:42:30 2018 +1100

    Javadoc for Piece.getCovered should specify to return -1 for off-board
    
    If a part of the piece lies off the board, Piece.getCovered should
    return -1 for that piece.

commit b36485e206b583b110af76c92f5bc8713e9b65ed
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sat Feb 24 20:34:27 2018 +1100

    Javadoc for Task 6 getSolutions is inconsistent with Task 4 fixOrientations
    
    Piece E is also symmetric.
    
    Thanks to Huang Sukai for pointing this out

commit 8b49f10a6e95d358075c9f1ecc0bf38e9f4240d6
Author: u6361796 <u6361796@anu.edu.au>
Date:   Sat Feb 24 14:50:43 2018 +1100

    task 5 almost done.

commit ab14e226894201e66a0dfa224fe56b58c7521777
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sat Feb 24 12:17:15 2018 +1100

    fix typos in Javadoc for establishSampleObjectives
    
    Thanks to Chen Kunpeng for finding these

commit 1944b65ece0e5731c6f1e31d891acf4d1c74a44a
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Fri Feb 23 22:15:57 2018 +1100

    updated FixOrientationsTest to correctly require orientations to be fixed for piece 'E'
    
    Thanks to Huang Sukai for discovering this bug

commit 266affec6955d371f8d82b325dddfc345bd241d8
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Fri Feb 23 22:14:39 2018 +1100

    Tasks 2 and 3 had their numbers swapped in IQPuzzlerPro
    
    Thanks to Chaahat Jain for pointing this out

commit 1f5137d5dcbed73710c2536a7148e21f642bd92e
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Fri Feb 23 07:32:52 2018 +1100

    Task 7 for HD

commit 85492dc7b0a2f9942ae8f95962b73c466a636cbc
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Fri Feb 23 07:31:29 2018 +1100

    mention how to move pieces

commit 8cc981eb79360122d4f3e2aac967015af75de34f
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Fri Feb 23 07:14:10 2018 +1100

    add run configurations

commit 323d28240470223be995a6333014e35e63da2d9f
Author: milthorpe <josh.milthorpe@gmail.com>
Date:   Fri Feb 23 07:10:56 2018 +1100

    publish Assignment 1 2018

commit c7e4051158287b532927e5bad1856f51385f0b30
Author: milthorpe <josh.milthorpe@gmail.com>
Date:   Sun Feb 18 22:08:30 2018 +1100

    created repository; assignment not yet released
```
## Changes
```
Only in comp1110-ass1: feedback.md
Only in comp1110-ass1/.idea: vcs.xml
Only in comp1110-ass1/.idea: workspace.xml
diff -ru -x .git /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/originality.md comp1110-ass1/originality.md
--- /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/originality.md	2018-03-09 17:32:18.124389549 +1100
+++ comp1110-ass1/originality.md	2018-03-09 17:50:01.843547507 +1100
@@ -7,8 +7,8 @@
 
 I declare that the work I have submitted for assignment one is entirely my own work, with the following documented exceptions:
 
-* The idea of <...> came from a discussion with <...>
+* The idea of <Bit Board, bit shift> came from a discussion with <Aaron (Hang) Zhou>
 
 * The code in class <...> uses an idea suggested by <...>
 
-Signed: Mary Jones (u2345678)
\ No newline at end of file
+Signed: Wenbo Du (u6361796)
\ No newline at end of file
Only in comp1110-ass1: out
diff -ru -x .git /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/gui/Game.java comp1110-ass1/src/comp1110/ass1/gui/Game.java
--- /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/gui/Game.java	2018-03-09 17:32:18.616390812 +1100
+++ comp1110-ass1/src/comp1110/ass1/gui/Game.java	2018-03-09 17:50:04.971556645 +1100
@@ -58,7 +58,6 @@
  * - Using IllegalArgumentExceptions to check for and flag errors
  */
 public class Game extends Application {
-
     /* board layout */
     private static final int SQUARE_SIZE = 40;
     private static final int MARGIN_X = SQUARE_SIZE;
Only in comp1110-ass1/src/comp1110/ass1: IQPuzzlerPro.class
diff -ru -x .git /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/IQPuzzlerPro.java comp1110-ass1/src/comp1110/ass1/IQPuzzlerPro.java
--- /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/IQPuzzlerPro.java	2018-03-09 17:32:18.404390268 +1100
+++ comp1110-ass1/src/comp1110/ass1/IQPuzzlerPro.java	2018-03-09 17:50:04.795556130 +1100
@@ -1,5 +1,4 @@
 package comp1110.ass1;
-
 import java.util.*;
 
 /**
@@ -86,7 +85,7 @@
      * @param difficulty A value between 0.0 (easiest) and 10.0 (hardest) specifying the desired level of difficulty.
      */
     public IQPuzzlerPro(double difficulty) {
-        objective = establishInterestingObjective(difficulty);
+        //objective = establishInterestingObjective(difficulty);
         if (objective == null)
             objective = establishSimpleObjective(difficulty);
     }
@@ -108,10 +107,20 @@
      * @return true if the placement of the given piece is fixed in current puzzle objective;
      * otherwise return false
      */
-    public boolean isPieceFixed(char piece) {
-        // FIXME Task 2:  Replace the code below with code that correctly checks the objective
-        return false;
-    }
+        public boolean isPieceFixed(char piece) {
+            int length = objective.length();//length represent the length of fixed objective;
+            for (int i = 0; i < length; i += 4) {//pick one letter every four letter,represent the piece.
+                char eachPiece = objective.charAt(i);
+                if (eachPiece == piece) {//check whether the char input is the same as char looped.
+                    return true;
+                }
+            }//the loop finished means the input is not equal the any pieces, so it did not appear in objective.
+            return false;
+            // FIXME Task 2:  Replace the code below with code that correctly checks the objective
+
+        }
+
+
 
     /**
      * Set the game's objective using the given difficulty level and the sample
@@ -138,10 +147,30 @@
      * @param difficulty A value between 0.0 (easiest) and 10.0 (hardest) specifying the desired level of difficulty.
      */
     public static String establishSimpleObjective(double difficulty) {
+        Random r=new Random();
+        int randomIndex;//the number represent random selected index.
+        String outObj;//output the objective according to difficulty.
+        if (0.0<=difficulty&&difficulty<2.5){//level 1
+            randomIndex=r.nextInt(SAMPLE_OBJECTIVES[0].length);
+            outObj=SAMPLE_OBJECTIVES[0][randomIndex];
+        }
+        else if (2.5<=difficulty&&difficulty<5){//level 2
+            randomIndex=r.nextInt(SAMPLE_OBJECTIVES[1].length);
+            outObj=SAMPLE_OBJECTIVES[1][randomIndex];
+        }
+        else if (5<=difficulty&&difficulty<7.5){//level 3
+            randomIndex=r.nextInt(SAMPLE_OBJECTIVES[2].length);
+            outObj=SAMPLE_OBJECTIVES[2][randomIndex];
+        }
+        else {//level 4
+            randomIndex=r.nextInt(SAMPLE_OBJECTIVES[3].length);
+            outObj=SAMPLE_OBJECTIVES[3][randomIndex];
+        }
+        return outObj;
         // FIXME Task 4:  Replace the code below with code that draws from SAMPLE_OBJECTIVES
-        return TRIVIAL_OBJECTIVE;
     }
 
+
     /**
      * Determine whether a given piece placement string is valid.
      * A pieces placement string is valid if and only if:
@@ -222,9 +251,116 @@
      * @param difficulty A value between 0.0 (easiest) and 10.0 (hardest) specifying the desired level of difficulty.
      */
     public static String establishInterestingObjective(double difficulty) {
+        //the test takes 5-20 second.
+         if (difficulty<1.25)
+            return selectObj(8);//when the difficulty is less than 1.25, random place 8 pieces on board
+        else if(difficulty<2.5)
+            return selectObj(7);//the following code place different numbers of pieces on board.
+         // Generally, as the level of difficulty increases, the numbers of placed pieces decrease,
+         // so the player have to place more pieces on board and it is more challenging.
+        else if (difficulty<3.75)
+            return selectObj(6);
+        else if(difficulty<5)
+            return selectObj(5);
+        else if(difficulty<6.25)
+            return selectObj(4);
+        else if(difficulty<7.5)
+            return selectObj(3);
+        else if(difficulty<8.75)
+            return selectObj(2);
+        else
+            return selectObj(1);
         // FIXME Task 7: Replace this code with a good objective generator that does not draw from a simple set of samples
-        return null;
     }
+    static String board="0000000000000000000000000000000000000000000000000000000";
+    // a string formed by 55 "0" represent an empty board.
+    static List<Character> allPiece=Arrays.asList('A','B','C','D','E','F','G','H','I','J','K','L');
+    //all playable piece in the game.
+    static List<Character> usedPiece=new ArrayList<>();
+    // all used pieces.
+    private static String randomPlacement(){
+        Random r=new Random();
+        Character piece;
+        while (true) {
+            piece = allPiece.get(r.nextInt(allPiece.size()));
+            // random select a piece.
+            if (!usedPiece.contains(piece))
+                //check whether it has been used, if no, use the piece.
+                break;
+        }
+        int placement=r.nextInt(55);//random place the piece.
+        Character col=(char) ('A'+(placement%11));//find the column of placement.
+        Character row= (char) ('A'+(placement/11));//find the row of placement.
+        Character orientation;
+        if ('A'<=piece&&piece<='E'){
+            orientation=(char) ('A'+r.nextInt(4));
+        }
+        else {
+            orientation=(char) ('A'+r.nextInt(8));
+        }//random select the orientation of piece(note for piece 'A'-'E' flip is not allowed.
+        String formed=piece.toString()+col.toString()+row.toString()+orientation.toString();
+        return formed;//output a string represent the placement, type and orientation of piece.
+    }
+    private static boolean ifValidPlacement(String placement ){
+        Piece piece=Piece.valueOf(((Character)placement.charAt(0)).toString());
+        //convert piece represent in character to type piece.
+        int[] covered=piece.getCovered(placement.charAt(1),placement.charAt(2),placement.charAt(3));
+        //all the index covered by the piece.
+        for (int r:covered){// check whether each covered index valid.
+            if (r>54||r<0){
+                return false;//outbound
+            }
+            else if (board.charAt(r)=='1'){
+                return false;//overlap
+            }
+            else {
+                board=board.substring(0,r)+"1"+board.substring(r+1);
+                //the index is valid, so change the "0" to "1" on the index.
+            }
+        }
+        return true;//all index covered is valid,so the placement is valid.
+    }
+    private static String genObjective(int num){//random generate an objective.
+        String out="";//initialise the output objective.
+        int count=0;
+        while (true){
+            String placePiece=randomPlacement();//a random generated piece placement.
+            Character placed=placePiece.charAt(0);
+            if (ifValidPlacement(placePiece)&&(!usedPiece.contains(placed))){
+                out+=placePiece;
+                // if placement is valid and the piece is not used, add it to objective
+                usedPiece.add(placed);
+                //add the piece the used list.
+            }
+            count++;
+            if (count>1000){
+                //set a "timeout",eg. when we need to place 3 piece, we have already place
+                // two valid ones, but the third one can not fit in any place with any locations,
+                //the program will get into an infinite loop, this part avoid that and output an
+                //invalid objective(no enough piece)
+                break;
+            }
+            if (out.length()==4*num)//case when we find valid placement for all pieces.
+                break;
+        }
+        return out;
+    }
+    private static String selectObj(int num){
+        String obj;
+        while (true){
+            obj=genObjective(num);//generate a objective according to the number of pieces.
+            // but not necessarily valid.
+            usedPiece=new ArrayList<>();
+            //set back the list of used pieces to empty for the generation of another objective.
+            board="0000000000000000000000000000000000000000000000000000000";
+            //set back the origin empty board.
+            if (obj.length()==num*4){
+                break;//case when we find valid objective.
+            }
+        }
+        return fixOrientationsProperly(obj);//fix the orientation of objective and return it.
+    }
+
 
     /**
      * @return the objective of the current game.
@@ -256,10 +392,32 @@
      * @return the input string with corrected orientations for pieces 'A' through 'E'
      */
     public static String fixOrientations(String in) {
-        // FIXME Task 3: implement code that correctly returns a canonical string according to the comment above.
-        return in;
+        int length=in.length();//the length of input string(in)
+        String fixObjective="";//fixed objective to output.
+        for (int i=0;i<length;i+=4){//loop over every 4 char which represent for
+            String piece=in.substring(i,i+4);//a single piece
+            fixObjective+=fixSingleOrientation(piece);//fix the orientation and add to fixObjective.
+        }
+        return fixObjective;
+        // FIXME Task 2: implement code that correctly returns a canonical string according to the comment above.
+    }
+    private static String fixSingleOrientation(String piece) {//fix the orientation of a single piece.
+        String fixedPiece;//the orientation-fixed piece.
+        if (('A'<=piece.charAt(0)&&piece.charAt(0)<='E')&&('E' <= piece.charAt(3) && piece.charAt(3) <= 'H')) {
+            //the case when the piece is selected from 'A'-'E', and its orientation is between 'E' and 'H'.
+            fixedPiece = piece.substring(0, 3) + ((Character) (char) (piece.charAt(3) - 4)).toString();
+            // change the char represent orientation so that the piece is fixed.
+        }
+        else {
+            fixedPiece=piece;
+            //else just return the original piece.
+        }
+        return fixedPiece;
     }
 
+    // FIXME Task 3: implement code that correctly returns a canonical string according to the comment above.
+
+
     /**
      * Take a non-empty string composed of four-character piece placement strings,
      * and if the piece name is 'B' or 'D' and the orientation is any char 'E'-'H',
@@ -300,10 +458,10 @@
         for (int i = 0; i < in.length(); i += 4) {
             int rotation = placementChars[i + 3] - 'A';
             if ((placementChars[i] == 'A' || placementChars[i] == 'C' || placementChars[i] == 'E')
-                    && (rotation >= 4)) {
-                rotation = (rotation + 1) % 4;
+                    && (rotation > 4)) {
+                rotation = rotation + 1 % 4;
             } else if ((placementChars[i] == 'B' || placementChars[i] == 'D')
-                    && (rotation >= 4)) {
+                    && (rotation > 4)) {
                 rotation -= 4;
             } else if ((placementChars[i] == 'H')
                     && (rotation % 4 == 2 || (rotation % 4 == 3))) {
@@ -327,9 +485,239 @@
      * If there are no solutions, the array should be empty (not null).
      */
     public String[] getSolutions() {
+        /*getSolution may take 50s to 90s */
+        String[] out;
+        if (objective.length()==12*4)
+            //case when all the pieces are placed so there is no need for place pieces.
+        {out=new String[0];
+            return out;}
+        Set<String> ans=findSolution();
+        if (ans.isEmpty())//case there is no solution.
+        { out=new String[0];
+            return out;}
+            int count=0;
+        out=new String[ans.size()];// case when there are solutions.
+        for (String string:ans){
+            out[count]=objective+string;//string represents each solution(only pieces to play).
+            count++;//to convert a set of solutions to array.
+        }
+        return out;
         // FIXME Task 6: replace this code with code that determines all solutions for this puzzle's objective
-        return new String[]{TRIVIAL_SOLUTION};
     }
+    private Long objCovered(String objective){
+        //present the board after the placement of objective
+        //In order to use bitBoard and bitwise operator, convert the board to type Long.
+        Piece piece;
+        char col;
+        char row;
+        char orientation;
+        for (int i=0;i<objective.length();i+=4){
+            piece=Piece.valueOf(objective.substring(i,i+1));
+            col=objective.charAt(i+1);
+            row=objective.charAt(i+2);
+            orientation=objective.charAt(i+3);
+            for (int t:piece.getCovered(col,row,orientation))
+            {
+                fixedBoard=fixedBoard.substring(0,t)+"1"+fixedBoard.substring(t+1);
+            }//update the board.
+        }
+        Long binaryBoard=Long.parseLong(fixedBoard,2);
+        // convert binary string to type long for bit shift.
+        return binaryBoard;
+    }
+    private static Long intiPlacement(Character piece,char orientation){
+        Piece r=Piece.valueOf(piece.toString());
+        // For each piece intended to place, first place it at the top-left of the board.
+        int[] initCovered=r.getCovered('A','A',orientation);
+        // find the covered index.
+        String initBoard="0000000000000000000000000000000000000000000000000000000";
+        for (int a:initCovered){
+            initBoard=initBoard.substring(0,a)+"1"+initBoard.substring(a+1);
+            //update to the board when the piece is placed.
+        }
+        Long out=Long.parseLong( initBoard,2);
+        //convert the board to Long to use bit shift.
+        return out;
+    }
+    private String shift(Character piece,Character orientation){
+        //move the piece to right or down side until find a location the piece can fit in.
+        Long initBoard=intiPlacement(piece,orientation);
+        int count=0;
+        Piece p=Piece.valueOf(piece.toString());
+        int limit;
+        //limit represent the index when the last index of location where piece can place.
+        // it is related the orientation of piece.
+        if ((orientation-'A')%2==0)
+        {
+            limit=55-(p.getRowExtent()-1)*11-p.getColumnExtent();}
+        else{
+            limit=55-(p.getColumnExtent()-1)*11-p.getRowExtent();}
+        String flag="";
+        //used later to indicate that the function finally did not find a piece where the piece can fit in.
+        while ((Long.parseLong(fixedBoard,2)&initBoard)!=0){
+            //the piece is overlapped with objective
+            initBoard=initBoard>>1;//move the index of piece(add 1).
+            if (count==limit)
+                //finally the piece is going to be outbounded, set the flag to 1 means the piece can not be place.
+            {flag="1";
+                break;}
+            count++;
+        }
+        Long b=Long.parseLong(fixedBoard,2);
+        if (flag.equals(""))
+            fixedBoard=Long.toBinaryString(b+initBoard);
+        //flag is not set, so the piece is located, update the fixed board
+        // change some 0 to 1 as these points are not playable.
+        Character col=(char)(count%11+'A');
+        Character row=(char)(count/11+'A');
+        out=(piece.toString()+col.toString()+row.toString()+orientation)+flag;
+        //return the string represent the placement of piece.
+        // note the when the flag is set, the length of out is not 4,so out is invalid.
+        return out;
+    }
+    private List<Character> remainPiece(){
+        String placement=getObjective();
+        List<Character> all= new ArrayList<>();
+        all.add('A');
+        all.add('B');
+        all.add('C');
+        all.add('D');
+        all.add('E');
+        all.add('F');
+        all.add('G');
+        all.add('H');
+        all.add('I');
+        all.add('J');
+        all.add('K');
+        all.add('L');
+        List<Character> used=new ArrayList<>();
+        for (int j=0;j<placement.length();j+=4) {
+            Character piece = placement.charAt(j);
+            used.add(piece);
+        }
+        List<Character> out=new ArrayList<>();
+        for (Character l:all){
+            if (!used.contains(l))
+            {out.add(l);}
+        }
+        return out;
+    }
+    String fixedBoard="0000000000000000000000000000000000000000000000000000000";
+    //origin board without any piece on board.
+    String out="";
+    //all placement of remain pieces.
+    private Set<String> findSolution(){
+        Set<String> ans=new HashSet<>();//all solution for the objective.
+        String out;//ont solution
+        List<String> allorientation=allOrientation();
+        //all possible combination of the orientation of remaining pieces.
+        List<List<Character>> allorder=allOrder();
+        //all possible order of placement of piece.
+        for (List<Character>list:allorder) {
+            //generate solution based on every orientation and order.eg. (A__D)(F__H)(B__C)
+            for (String allori:allorientation){
+                objCovered(getObjective());
+                out="";
+                int index=0;
+                while (index<allori.length()){
+                    out+=(shift(list.get(index),allori.charAt(index)));//generate an solution
+                    index++;
+                }
+                if ((fixedBoard.equals("1111111111111111111111111111111111111111111111111111111"))&&ifValidOri(out))
+                {//case when all index are covered, a valid solution formed.
+                    ans.add(fixedOrder(fixOrientationsProperly(fixOrientations(out))));
+                }
+                fixedBoard="0000000000000000000000000000000000000000000000000000000";
+                //initialise the board again for next loop.
+        }
+        }
+        return ans;
+    }
+    private boolean ifValidOriSingle(String string){
+        //determine whether a placement is valid:
+            //for piece 'A'-'E' ,no flipping.
+        char piece=string.charAt(0);
+        char orientation=string.charAt(3);
+        if (((piece=='A')||(piece=='B')||(piece=='C')||(piece=='D')||(piece=='E'))&&
+                ((orientation=='E')||(orientation=='F')||(orientation=='G')||(orientation=='H'))){
+            return false;
+            }
+            return true;
+        }
+    private boolean ifValidOri(String string){
+        //check all placement of orientation is valid.
+            // (cannot used fixOrientation due to my function design issue).
+        for (int i=0;i<string.length();i+=4){
+            if (!ifValidOriSingle(string.substring(i,i+4))){
+                return false;
+            }
+        }
+        return true;
+        }
+    private List<String> allOrientation(){
+        Random r=new Random();//generate all permutation of orientation.
+        Set<String> out=new HashSet<>();
+        int length=remainPiece().size();
+        int lengthCopy=length;
+        int sum=1;
+        while (lengthCopy>0){
+            sum=sum*8;
+            lengthCopy--;
+        }
+        while (out.size()<sum)
+        {String temp="";
+        for (int i=0;i<length;i++){
+            Character or=(char) (r.nextInt(8)+'A');
+            temp+=or.toString();
+        }
+        out.add(temp);
+        }
+        List<String> realOut=new ArrayList<>(out);
+        return realOut;
+        }
+    private List<List<Character>>allOrder(){
+        //generate all orders of placement.
+        Set<List<Character>> out=new HashSet<>();
+        int sum=1;
+        List<Character> allPiece=remainPiece();
+        int length=allPiece.size();
+        while(length>0){
+            sum=sum*length;
+            length--;
+        }
+        while (out.size()<sum){
+            List<Character> copy=remainPiece();
+            Collections.shuffle(copy);
+            out.add(copy);
+        }
+        List<List<Character>> realout=new ArrayList<>(out);
+        return realout;
+        }
+    private String fixedOrder(String in){
+        //turn all solution to a fixed order.eg: ABCEFACDBACA->ABCEBACAFACD
+        String out="";
+        int length=in.length();
+        List<Character> tempCh=new ArrayList<>();
+        List<String> tempStr=new ArrayList<>();
+        for (int i=0;i<length;i+=4){
+            tempCh.add(in.charAt(i));
+            tempStr.add(in.substring(i,i+4));
+        }
+        Collections.sort(tempCh);
+        for (Character ch:tempCh){
+            for (String str:tempStr){
+                if (str.charAt(0)==ch)
+                    out+=str;
+            }
+        }
+        return out;
+        }
+
+
+
+
+
+
 
     /**
      * Return the solution to the puzzle.  The solution is calculated lazily, so first
Only in comp1110-ass1/src/comp1110/ass1: Piece.class
diff -ru -x .git /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Piece.java comp1110-ass1/src/comp1110/ass1/Piece.java
--- /students/u3179443/comp1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Piece.java	2018-03-09 17:32:18.516390555 +1100
+++ comp1110-ass1/src/comp1110/ass1/Piece.java	2018-03-09 17:50:04.871556353 +1100
@@ -1,5 +1,11 @@
 package comp1110.ass1;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static java.util.Collections.min;
+
 /**
  * An enumeration representing the twelve pieces in the IQPuzzlerPro game.
  * <p>
@@ -71,36 +77,103 @@
     /**
      * Return indices corresponding to which board spaces would be covered
      * by this piece, given a correct provided placement.
-     * If a part of the piece would lie off the board in a given orientation,
-     * return -1 for that part of the piece.
      * <p>
      * Examples:
      * Given the piece placement string 'GACA' would return the indices: {22,23,24,33,34}.
-     * Given the piece placement string 'HGBF' would return the indices: {17,28,29,40}.
-     * Given the piece placement string 'JBCB' would return the indices: {-1,23,24,35,46}.
-     * <p>
-     * Hint: You can associate values with each entry in the enum using a constructor,
-     * so you could use that to somehow encode the properties of each of the twelve pieces.
-     * Then in this method you could use the value to calculate the required indices.
-     * <p>
-     * See the 'Grade' enum given in the O2 lecture as part of the lecture code (live coding),
-     * for an example of an enum with associated state and constructors.
-     * <p>
-     * The tutorial here: http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
-     * has an example of a Planet enum, which includes two doubles in each planet's
-     * constructor representing the mass and radius.   Those values are used in the
-     * surfaceGravity() method, for example.
-     *
-     * @param column      the column in which the origin of the piece is placed ('A' to 'K')
-     * @param row         the row in which the origin of the tile is placed ('A' to 'E')
-     * @param orientation which orientation the tile is in ('A' to 'H')
-     * @return A set of indices corresponding to the board positions that would be covered by this piece
-     */
+//     * Given the piece placement string 'HGB.l.l//.....F' would return the indices: {17,28,29,40}.
+//     * <p>
+//     * Hint: You can associate values with each entry in the enum using a constructor,
+//     * so you could use that to somehow encode the properties of each of the twelve pieces.
+//     * Then in this method you could use the value to calculate the required indices.
+//     * <p>
+//     * See the 'Grade' enum given in the O2 lecture as part of the lecture code (live coding),
+//     * for an example of an enum with associated state and constructors.
+//     * <p>
+//     * The tutorial here: http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
+//     * has an example of a Planet enum, which includes two doubles in each planet's
+//     * constructor representing the mass and radius.   Those values are used in the
+//     * surfaceGravity() method, for example.
+//     *
+//     * @param column      the column in which the origin of the piece is placed ('A' to 'K')
+//     * @param row         the row in which the origin of the tile is placed ('A' to 'E')
+//     * @param orientation which orientation the tile is in ('A' to 'H')
+//     * @return A set of indices corresponding to the board positions that would be covered by this piece
+//     */
     int[] getCovered(char column, char row, char orientation) {
+        Square [] finalShape;//final after rotate, flip.
+        if (orientation<='D'){
+           finalShape=rotatedTime(orientation-'A',shape);}
+        else {
+             finalShape=(rotatedTime(orientation-'E',flip(shape)));
+        }
+        Square [] outShape=relocated(finalShape);//piece after relocates.
+        int lengthOfShape=outShape.length;
+        int [] out=new int [lengthOfShape];// the index that the piece covered.
+        int count=0;
+        for (Square o:outShape){
+            out[count]=(column-'A')+((row-'A')*11)+o.row*11+o.col;
+            if (out[count]>54||out[count]<0)
+                out[count]=-1;// the placement is out of bound
+            count++;
+        }
+        return out;
         // FIXME Task 5: implement code that correctly creates an array of integers specifying the indices of the covered spaces
-        return new int[]{};
     }
+    public Square [] rotate(Square [] shape){
+        //rotate the piece by operating on every piece
+        Square [] rotated=new Square[shape.length];//piece that is rotated
+        int index=0;
+        for (Square sq:shape){//loop over every piece to rotate.
+            int newRow=sq.col;
+            int newColumn=sq.row;
+            Square r=new Square(-newColumn,newRow);
+            rotated[index]=r;
+            index++;
+        }
+        return rotated;
+    }
+    public Square [] rotatedTime(int times,Square [] shape){
+        if (times==0)//rotate several times by instruction.
+            return shape;
+        else if(times==1)
+            return rotate(shape);
+        else if(times==2)
+            return rotate(rotate(shape));
+        else
+            return rotate(rotate(rotate(shape)));
+    }
+    public Square [] flip(Square [] shape){
+        // flip piece by flip each square.
+        Square [] filped=new Square[shape.length];
+        int count=0;
+        for (Square  l:shape){
+            filped[count]=new Square(-l.col,l.row);
+            count++;
+        }
+        return filped;
 
+    }
+    public  Square [] relocated(Square [] shape) {
+        //move the piece(rotated and flipped) to achieve the instruction:
+        // the top-left location stays the same.
+        int columnMin;
+        int rowMin;
+        List rowList=new ArrayList();
+        List columnList=new ArrayList();
+        for (Square j:shape){
+            rowList.add(j.row);
+            columnList.add(j.col);
+        }
+        columnMin= (int )Collections.min(columnList);
+        rowMin= (int)Collections.min(rowList);
+        Square [] out=new Square[shape.length];
+        int index=0;
+        for (Square p:shape){
+            out[index]=new Square(p.col-columnMin,p.row-rowMin);
+            index++;
+        }
+        return out;
+    }
     public int getColumnExtent() {
         int xMax = 0;
         for (Square square : shape) {
Only in comp1110-ass1/src/comp1110/ass1: Piece$Square.class
```
## Test log
```
Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
..
Time: 0.012

OK (2 tests)

Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
.....
Time: 0.009

OK (5 tests)

Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
...
Time: 0.016

OK (3 tests)

Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
.......
Time: 0.026

OK (7 tests)

Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
......
Time: 37.249

OK (6 tests)

Picked up _JAVA_OPTIONS: -Xmx512M
JUnit version 4.12
...
Time: 5.137

OK (3 tests)

```
